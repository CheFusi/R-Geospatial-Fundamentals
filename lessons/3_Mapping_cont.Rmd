---
title: "Mapping_2"
output: html_document
date: "2024-01-12"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 

# Learning Objectives

Welcome to R Geospatial Fundamentals. Our goals for today's workshop are:

1.  **Understand classification schemes for plotting vector data**

2.  ...

------------------------------------------------------------------------

## Basis of plotting geospatial data

-   

-   

-   

[Load libraries]{.underline}

```{r}

library(here) #provides a here() command that builds file paths from the project directory
library(sf)
library(tmap)
```

[Load in datasets]{.underline}

```{r}

#read in the shapefile
counties = st_read(dsn = here("data",  #dsn= data source name
                              "california_counties", 
                              "CaliforniaCounties.shp"))

#read in the schools_sf shapefile using a slightly different syntax
schools_sf = st_read(here("data",
                               "California_Schools_2019-20",
                               "SchoolSites1920.shp"))


#data sources: 
# counties: https://gis.data.ca.gov/datasets/8713ced9b78a4abb97dc130a691a8695 
# schools_sf: https://gis.data.ca.gov/datasets/f7f818b0aa7a415192eaf66f192bc9cc
```

### 

# Classification schemes

-   Another way to make more meaningful maps is to improve the way in which data values are associated with colors.

-   The common alternative to the proportional color maps we've created thus far is to use a **classification scheme** to create a **graduated color map**.

-   A **classification scheme** is a method for binning continuous data values into multiple classes (often 4-7) and then associate those classes with the different colors in a color palette.

-   The commonly used classification schemes include equal interval, quantiles, natural breaks, heads/tails, and manual schemes. the `?tm_polygons` documentation, under the `style` argumnt provides keywords names for the different classification styles

Let's explore each classifications schemes:

------------------------------------------------------------------------

**A. Classifying data based on Equal intervals** (e.g. **pretty)**

An Equal-interval classification segments data into equal-size data ranges (e.g., values within 0-10, 10-20, 20-30, etc.)

-   pros:
    -   best for data spread across the entire range of values
    -   easily understood by map readers
-   cons:
    -   avoid if you have highly skewed data or a few big outliers because one or more of the bins may have no data observations

ðŸ”” **Question**: Do you recall what transforming count data into density data means?

```{r}

#create a new column that contains the multi_race density data
counties$POP12_SQMI<-counties$POP2012/counties$SQ_MI
```

```{r}
tmap_mode('plot')
# Plot population density - mile^2
pretty_clasi_plot<- tm_shape(counties) + 
  tm_polygons(col = 'POP12_SQMI',
              alpha = 0.9,
              style = "pretty", #style of the break, pretty = equal interval
              title = "Population Density per mi^2 Equal-Interval Scheme")

pretty_clasi_plot
```

In instance where proportions don't make the data more representative, we can look to other classification schemes.

**B. Classifying data based on Quantiles**

A quantile scheme ditributes an equal number of observations in each bin

-   pros:

    -   looks nice, because it best spreads colors across full set of data values
    -   thus, it's often the default scheme for mapping software

-   cons:

    -   the bin ranges are based on the number of observations, not on the data values
    -   thus, different classes can contain very similar or very different data values

Now you try it! Plot the 'POP12_SQMI' counties data using the quantile style

-   What should you change `"pretty"` to?
-   Hint: you can take a look at the `?tm_polygons` documentation to find the correct syntax

```{r}

tmap_mode('plot')
# Plot population density - mile^2
quant_clasi_plot<- tm_shape(counties) + 
  tm_polygons(col = 'POP12_SQMI',
              alpha = 0.9,
              style = "quantile", #style of the break
              title = "Population Density per mi^2 Quantile Scheme") 
quant_clasi_plot
```

**C. Classifying data based on Natural breaks**

Natural breaks minimizes within-class variance and maximize between-class differences

-   pros:
    -   great for exploratory data analysis, because it can identify natural groupings
-   cons:
    -   class breaks are best fit to one dataset, so the same bins can't always be used for multiple years

```{r}
tmap_mode('plot')
# Plot population density - mile^2
nat_clasi_plot <- tm_shape(counties) + 
  tm_polygons(col = 'POP12_SQMI',
              style = "fisher", #style of the break
              alpha = 0.9,
              title = "Population Density per mi^2")
nat_clasi_plot
```

note the range of each bin

**D. Classifying data Manually**

user-defined classification schemes allow the user to manually set the breaks for the bins using the `breaks` argument.

-   pros:
    -   especially useful if you want to slightly change the breaks produced by another scheme
    -   can be used as a fixed set of breaks to compare data over time
-   cons:
    -   more work involved

```{r}

man_clasi_plot <- tm_shape(counties) + 
  tm_polygons(col = 'POP12_SQMI',
              style = 'fixed',
              breaks = c(0, 50, 100, 200, 300, 400, max(counties$POP12_SQMI)),
              #labels = c('<50','50 to 100','100 to 200','200 to 300','300 to 400','>400'),
              title = "Population Density per Square Mile Manual Scheme")
man_clasi_plot
```

------------------------------------------------------------------------

## ðŸ¥Š Challenge 3: Classifying data based on **Head/Tails**

**D.** Classifying data based on **Head/Tails**

The heads/Tails scheme is tailored to data with a heavy-tailed distributions

-   search the `?tm_polygons` documentation to find the appropriate argument for a heads/tails classification

-   create a plot named 'HeadsTails_clasi_plot' using a heads/tails scheme

-   create a combined variable named 'combined_clasi_plots' that shows the 4 plots, with. columns

Solution

```{r}

library(tmaptools)

HeadTails_clasi_plot <- tm_shape(counties) + 
  tm_polygons(col = 'POP12_SQMI',
              style = "headtails", #style of the break
              alpha = 0.9,
              title = "Population Density per mi^2 Headtails Scheme")
HeadTails_clasi_plot

# Assuming you have tmap plots named plot1, plot2, plot3, and plot4
combined_clasi_plots <- tmap_arrange(quant_clasi_plot, nat_clasi_plot, man_clasi_plot, HeadTails_clasi_plot, ncol = 2)

# View the combined plots
combined_clasi_plots

```

-   see the documentation `?classIntervals` or sources such as [Geocomputation with R](https://geocompr.robinlovelace.net/adv-map.html) ebook for more information.

-   other mapping packages include

    -   `mapview`: for a quick and easy interactive map

    -   `leaflet`: for highly custom interactive maps that you can output and host on a website

    -   `shiny`: for interactive R based applications that use leaflet maps

------------------------------------------------------------------------

## Key Points

\<Summary of what was learned in today's workshop.\>

-   \<key point 1\>
